'''
approach 1
Find the pivot by traversing the array linearly and in the process if you find k, break and return the idx.
Ans how to find the pivot, start from left and stop at the index where there is a decrease.
now,even after finding the pivot if I didn't find my ans,my target is in the right half and I shall do a binary search 
with low = pivotIndex +  1 and high = len(arr) - 1
'''
pivotIdx = 0
pos = -1
while arr[pivotIdx] < arr[pivotIdx + 1]:
    if arr[pivotIdx] == target:
        pos = pivotIdx
        break
    pivotIdx += 1
if pos == -1:
    low = pivotIdx + 1
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            pos = mid
            break
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
print(pos)

'''
'''
approach 2
Take low and high and in a while loop, compute mid and if nums[mid] == target, return mid;find the sorted half with 
the logic that if nums[mid] > nums[low] --> left half is sorted
else right half is sorted.
after finding sorted half, check if target is in sorted half's range, if not update the pointers.
This works in a greedy approach in a sense by looking out only for sorted portion and updating pointers.
'''

low = 0
        high = len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] == target:
                return mid
            if nums[low] < nums[mid]:
                """
                Left portion is sorted and right portion is distorted.
                """
                if nums[low] <= target < nums[mid]:
                    high = mid - 1
                else:
                    low = mid + 1
            else:
                """
                Right portion is sorted and left portion is distorted.
                """
                if nums[high] >= target > nums[mid]:
                    low = mid + 1
                else:
                    high = mid - 1
