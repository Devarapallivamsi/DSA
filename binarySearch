Pb links may be present on striver's website.

1.Searching minimum in rotated sorted array
import math

nums = [4, 5, 6, 7, 1, 2, 3]
minEle = math.inf
low = 0
high = len(nums) - 1

while low <= high:
    mid = (low + high) // 2
    # left half is sorted;
    if nums[mid] >= nums[low]:
        minEle = min(nums[low], minEle)
        low = mid + 1
    else:
        minEle = min(nums[mid], minEle)
        # right half is sorted;
        high = mid - 1
print(minEle)

======================================================================================

2.Finding pivotIdx (Index of min element) in a rotated sorted array:
import math

nums = [4, 5, 6, 2, 3]
left = 0
right = len(nums) - 1
pivot = math.inf
pivotIdx = None
while left < right:
    mid = (left + right) // 2
    pivot = min(pivot, nums[mid])
    if nums[left] <= nums[mid]:
        if nums[left] <= pivot:
            pivotIdx = left
        left = mid + 1
    else:
        if nums[mid] <= pivot:
            pivotIdx = mid
        right = mid - 1

print(f'pivotIdx: {pivotIdx}')
======================================================================================
3.searching element in rotated sorted array 1
'''
approach 1
Find the pivot by traversing the array linearly and in the process if you find k, break and return the idx.
Ans how to find the pivot, start from left and stop at the index where there is a decrease.
now,even after finding the pivot if I didn't find my ans,my target is in the right half and I shall do a binary search 
with low = pivotIndex +  1 and high = len(arr) - 1
'''
pivotIdx = 0
pos = -1
while arr[pivotIdx] < arr[pivotIdx + 1]:
    if arr[pivotIdx] == target:
        pos = pivotIdx
        break
    pivotIdx += 1
if pos == -1:
    low = pivotIdx + 1
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            pos = mid
            break
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
print(pos)

'''
'''
approach 2
Take low and high and in a while loop, compute mid and if nums[mid] == target, return mid;find the sorted half with 
the logic that if nums[mid] > nums[low] --> left half is sorted
else right half is sorted.
after finding sorted half, check if target is in sorted half's range, if not update the pointers.
This works in a greedy approach in a sense by looking out only for sorted portion and updating pointers.
'''

low = 0
high = len(nums) - 1
while low <= high:
    mid = (low + high) // 2
    if nums[mid] == target:
        return mid
    if nums[low] < nums[mid]:
        """
        Left portion is sorted and right portion is distorted.
        """
        if nums[low] <= target < nums[mid]:
            high = mid - 1
        else:
            low = mid + 1
    else:
        """
        Right portion is sorted and left portion is distorted.
        """
        if nums[high] >= target > nums[mid]:
            low = mid + 1
        else:
                    high = mid - 1

======================================================================================

4.  Finding element in rotated sorted array 2(array having duplicates)
"""
Approach: Just increment low and decrement high by one.Reason: I have got to know that nums[mid] is not my target,
so neither nums[low](=nums[mid]) or nums[high](=nums[mid]) will be my target!!
"""
low = 0
high = len(nums) - 1
while low <= high:
    mid = (low + high) // 2
    if nums[mid] == target:
        return mid
    if nums[low] == nums[mid] == nums[high]:
        low += 1
        high -= 1
        continue
    if nums[low] < nums[mid]:
        """
        Left portion is sorted and right portion is distorted.
        """
        if nums[low] <= target < nums[mid]:
            high = mid - 1
        else:
            low = mid + 1
    else:
        """
        Right portion is sorted and left portion is distorted.
        """
        if nums[high] >= target > nums[mid]:
            low = mid + 1
        else:
                    high = mid - 1

======================================================================================

5. Finding the only single occurring element where all others occur twice.
nums = [3, 3, 7, 7, 8, 8, 9, 11, 11]
low = 1
high = len(nums) - 2
while low <= high:
    mid = (low + high) // 2
    if nums[mid] != nums[mid - 1] and nums[mid] != nums[mid + 1]:
        print(nums[mid])
        break
    if (mid % 2 == 0 and nums[mid] == nums[mid + 1]) or (mid % 2 != 0 and nums[mid] == nums[mid - 1]):
        # I am on the left half and eliminate it.
        low = mid + 1
    else:
        # I am on the right half and eliminate it.
        high = mid - 1


6.# Finding the peak element(not pivot in rotated array!!) Idx in the array.
peak: An element that's greater than both of it's neighbours.
eg:
1. [1,4,7] possible ans(Idx): 1
2. [1,2,3,4,5,6,4,1,2,9,3] possible ans(Idx): 6, 9;
Approach:
If I am on the point where it prev number is greater, it implies that I am on a downward slope
so I have to move up.i.e, eliminate right half.
    def findPeakElement(self, nums):
        if len(nums) == 1:
            # Index of the only element present in nums.
            return 0
        if len(nums) == 2:
            return max(nums)

        low = 1
        high = len(nums) - 2
        while low <= high:
            mid = (low + high) // 2
            if nums[mid - 1] < nums[mid] and nums[mid] > nums[mid + 1]:
                return mid
            if nums[mid] < nums[mid - 1]:
                high = mid - 1
            else:
                low = mid + 1
        if nums[0] > nums[-1]:
            return 0
        else:
            return len(nums) - 1
