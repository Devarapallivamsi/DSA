
1.#Given an array of numbers,find Second smallest and second largest elements.
# optimal approach:
import math

small = math.inf
secondSmall = math.inf
large = -math.inf
secLarge = -math.inf

nums = [1, 2, 4, 7, 7, 5]

for i in nums:
    if i > large:
        large, secLarge = i, large
    elif i > secLarge and i != large:
        secLarge = i

    if i < small:
        small, secondSmall = i, small
    elif i < secondSmall and i != secondSmall:
        secondSmall = i

print(secLarge)
print(secondSmall)

======================================================================

2.Given a sorted array having duplicates, re arrange the array in-place in a way that all unique elements,
while preserving their order present at first.
eg: nums = [1,1,2,2,2,3,3,4,4,4]; After rearrangement: [1,2,3,4,numbers in any order]


Brute:
Make a traversal and keep adding the elements to an ordered set. As the set doesn't store repeated elements, 
just repopulate all the elements in the ordered set in the starting indices of the array.
M: Number of unique elements
N: All the given elements.
TC: while populating the set :O(N) + while repopulating: O(M)
SC: O(M) (For set)

Code:

from collections import OrderedSet
s = OrderedSet()

for i in nums:
    s.add(i)
nums[:len(s)] = [j for j in s]


Optimal:

This uses a two pointer approach:

My solution:
def removeDupicates(nums):
        i = 1
        j = 2
        while i <= len(nums) - 1 and j <= len(nums) - 1:
            # while nums[i - 1] <= nums[i]:
            #     i += 1
            # j = i + 1
            while nums[i - 1] >= nums[j]:
                j += 1
                if j > len(nums) - 1:
                    #nums = nums[:i]
                    return i
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j = i + 1

Leetcode Solution:
# Trace this to get an idea.
"""
Move the j pointer from index 1(potential idx having chances of a duplicate) and check for the element that's
different from i pointer (that refers to the unique elements). if I find any, just update the (i + 1)th index with j
and then increase i the pointer by 1. loop ends when j reaches the len(nums)-1.
"""
def removeDuplicates(nums):
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            nums[i + 1] = nums[j]
            i += 1
    return nums


====================================================================================

Move zeros to the end.
Pb: You are given an array of integers, your task is to move 
all the zeros in the array to the end of the array and move non-negative integers to
the front by maintaining their order.

arr = [1, 0, 2, 3, 0, 4, 0, 1]
o/p:  [1, 2, 3, 4, 1, 0, 0, 0]

Optimal:

def moveZeroesToEnd(nums):
    i = 0
    # Find the first zero.
    while nums[i] != 0:
        i += 1
    
    j = i + 1
    while j <= len(nums) - 1:
        if nums[j] != 0:
            # Swap the current zero with the first non-zero element that we come across while traversal.
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
        j += 1
    return nums

========================================================================================================
Problem Statement: Given two sorted arrays, arr1, and arr2 of size n and m. Find the union of two sorted arrays.

The union of two arrays can be defined as the common and distinct elements in the
two arrays.NOTE: Elements in the union should be in ascending order.



def union(a, b):
    merged = []
    i = 0
    j = 0
    
    # Loop until the lengths of the two lists are same.
    while i <= len(a)-1 and j <= len(b)-1:
        # If ele from first list is less,
        if a[i] < b[j]:
            merged.append(a[i])
            i += 1
        # If eles are equal.
        elif a[i] == b[j]:
            merged.append(a[i])
            i += 1
            j += 1
        # If ele from second list is greater,
        else:
            merged.append(b[j])
            j += 1
    """Note: Only one of the below gets executed and the other won't as the condition doesn't satisfies."""
    # Loop to append any leftover eles from list a
    while i <= len(a) - 1:
        merged.append(a[i])
        i += 1
    # Loop to append any leftover eles from list b
    while j <= len(b) - 1:
        merged.append(b[j])
        j += 1
    return merged

====================================================================================
Problem Statement: Given an array that contains only 1 and 0 
return the count of maximum consecutive ones in the array.

lst = [1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]

Optimal:
def maxConsecutiveOnes(arr):
    i = 0
    # Variable to be updated with maximum count of consecutive 1s
    maxCount = 0
    # Variable to count the consecutive 1s of a particular group.
    clusterCnt = 0
    while i < len(arr):
        # If we see 1, increase the (current) clusterCount by one.
        if arr[i] == 1:
            clusterCnt += 1
        # If we see a 0, it means we might have just came out of a group so, update the maxCount
        else:
            if clusterCnt > maxCount:
                maxCount = clusterCnt
                clusterCnt = 0
        i += 1
    return maxCount










