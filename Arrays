
1.#Given an array of numbers,find Second smallest and second largest elements.
# optimal approach:
import math

small = math.inf
secondSmall = math.inf
large = -math.inf
secLarge = -math.inf

nums = [1, 2, 4, 7, 7, 5]

for i in nums:
    if i > large:
        large, secLarge = i, large
    elif i > secLarge and i != large:
        secLarge = i

    if i < small:
        small, secondSmall = i, small
    elif i < secondSmall and i != secondSmall:
        secondSmall = i

print(secLarge)
print(secondSmall)

======================================================================

2.Given a sorted array having duplicates, re arrange the array in-place in a way that all unique elements,
while preserving their order present at first.
eg: nums = [1,1,2,2,2,3,3,4,4,4]; After rearrangement: [1,2,3,4,numbers in any order]


Brute:

Make a tarversal and keep adding the elements to an ordered set. As the set doesn't store repeated elements, 
just repopulate all the elements in the ordered set in the starting indices of the array.
M: Number of unique elements
N: All the given elements.
TC: O(N) + O(M)
SC: O(M)

Code:

from collections import OrderedSet
s = OrderedSet()

for i in nums:
    s.add(i)
nums[:len(s)] = [j for j in s]


Optimal:
This uses a two pointer approach:

My solution:
def removeDupicates(nums):
        i = 1
        j = 2
        while i <= len(nums) - 1 and j <= len(nums) - 1:
            # while nums[i - 1] <= nums[i]:
            #     i += 1
            # j = i + 1
            while nums[i - 1] >= nums[j]:
                j += 1
                if j > len(nums) - 1:
                    #nums = nums[:i]
                    return i
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j = i + 1

Leetcode Solution:
# Trace this to get an idea.
def removeDupicates(nums):
        j = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[j] = nums[i]
                j += 1
        return j

