
1.#Given an array of numbers,find Second smallest and second largest elements.
# optimal approach:
import math

small = math.inf
secondSmall = math.inf
large = -math.inf
secLarge = -math.inf

nums = [1, 2, 4, 7, 7, 5]

for i in nums:
    if i > large:
        large, secLarge = i, large
    elif i > secLarge and i != large:
        secLarge = i

    if i < small:
        small, secondSmall = i, small
    elif i < secondSmall and i != secondSmall:
        secondSmall = i

print(secLarge)
print(secondSmall)

======================================================================

2.Given a sorted array having duplicates, re arrange the array in-place in a way that all unique elements,
while preserving their order present at first.
eg: nums = [1,1,2,2,2,3,3,4,4,4]; After rearrangement: [1,2,3,4,numbers in any order]


Brute:
Make a traversal and keep adding the elements to an ordered set. As the set doesn't store repeated elements, 
just repopulate all the elements in the ordered set in the starting indices of the array.
M: Number of unique elements
N: All the given elements.
TC: while populating the set :O(N) + while repopulating: O(M)
SC: O(M) (For set)

Code:

from collections import OrderedSet
s = OrderedSet()

for i in nums:
    s.add(i)
nums[:len(s)] = [j for j in s]


Optimal:

This uses a two pointer approach:

My solution:
def removeDupicates(nums):
        i = 1
        j = 2
        while i <= len(nums) - 1 and j <= len(nums) - 1:
            # while nums[i - 1] <= nums[i]:
            #     i += 1
            # j = i + 1
            while nums[i - 1] >= nums[j]:
                j += 1
                if j > len(nums) - 1:
                    #nums = nums[:i]
                    return i
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j = i + 1

Leetcode Solution:
# Trace this to get an idea.
"""
Move the j pointer from index 1(potential idx having chances of a duplicate) and check for the element that's
different from i pointer (that refers to the unique elements). if I find any, just update the (i + 1)th index with j
and then increase i the pointer by 1. loop ends when j reaches the len(nums)-1.
"""
def removeDuplicates(nums):
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            nums[i + 1] = nums[j]
            i += 1
    return nums


====================================================================================

Move zeros to the end.
Pb: You are given an array of integers, your task is to move 
all the zeros in the array to the end of the array and move non-negative integers to
the front by maintaining their order.

arr = [1, 0, 2, 3, 0, 4, 0, 1]
o/p:  [1, 2, 3, 4, 1, 0, 0, 0]

Optimal:

def moveZeroesToEnd(nums):
    i = 0
    # Find the first zero.
    while nums[i] != 0:
        i += 1
    
    j = i + 1
    while j <= len(nums) - 1:
        if nums[j] != 0:
            # Swap the current zero with the first non-zero element that we come across while traversal.
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
        j += 1
    return nums


